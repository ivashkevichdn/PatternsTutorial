# ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ

Паттерны (или шаблоны) проектирования описывают
типичные способы решения часто встречающихся
проблем при проектировании программ.

## Классификация паттернов

Паттерны отличаются по уровню сложности, детализации и охвата проектируемой системы. Проводя аналогию со строительством, вы можете повысить безопасность перекрёстка, поставив светофор, а можете заменить перекрёсток целой автомобильной развязкой с подземными переходами.

Самые низкоуровневые и простые паттерны — идиомы. Они не универсальны, поскольку применимы только в рамках одного языка программирования.

Самые универсальные — архитектурные паттерны, которые можно реализовать практически на любом языке. Они нужны для проектирования всей программы, а не отдельных её элементов.

Кроме того, паттерны отличаются и предназначением. В этой книге будут рассмотрены три основные группы паттернов:

- **Порождающие паттерны** беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.

- **Структурные паттерны** показывают различные способы построения связей между объектами.

- **Поведенческие паттерны** заботятся об эффективной коммуникации между объектами.

## **Порождающие паттерны**

### Абстрактная фабрика _(Abstract Factory)_

**Абстрактная фабрика** — это порождающий паттерн проектирования, который решает проблему создания целых семейств связанных продуктов, без указания конкретных классов продуктов.

Абстрактная фабрика задаёт интерфейс создания всех доступных типов продуктов, а каждая конкретная реализация фабрики порождает продукты одной из вариаций. Клиентский код вызывает методы фабрики для получения продуктов, вместо самостоятельного создания с помощью оператора new. При этом фабрика сама следит за тем, чтобы создать продукт нужной вариации.

**Пример кода:** [Python](Generating/Python/abstract_factory.py)

### Строитель _(Builder)_

**Строитель** — это порождающий паттерн проектирования, который позволяет создавать объекты пошагово.

В отличие от других порождающих паттернов, Строитель позволяет производить различные продукты, используя один и тот же процесс строительства.

**Пример кода:** [Python](Generating/Python/builder.py)

### Фабричный метод _(Factory Method)_

**Фабричный метод** — это порождающий паттерн проектирования, который решает проблему создания различных продуктов, без указания конкретных классов продуктов.

Фабричный метод задаёт метод, который следует использовать вместо вызова оператора new для создания объектов-продуктов. Подклассы могут переопределить этот метод, чтобы изменять тип создаваемых продуктов.

**Пример кода:** [Python](Generating/Python/factory_method.py)

### Прототип _(Prototype)_

**Прототип** — это порождающий паттерн, который позволяет копировать объекты любой сложности без привязки к их конкретным классам.

Все классы — Прототипы имеют общий интерфейс. Поэтому вы можете копировать объекты, не обращая внимания на их конкретные типы и всегда быть уверены, что получите точную копию. Клонирование совершается самим объектом-прототипам, что позволяет ему скопировать значения всех полей, даже приватных.

**Пример кода:** [Python](Generating/Python/prototype.py)

### Одиночка _(Singleton)_

**Одиночка** — это порождающий паттерн, который гарантирует существование только одного объекта определённого класса, а также позволяет достучаться до этого объекта из любого места программы.

Одиночка имеет такие же преимущества и недостатки, что и глобальные переменные. Его невероятно удобно использовать, но он нарушает модульность вашего кода.

Вы не сможете просто взять и использовать класс, зависящий от одиночки в другой программе. Для этого придётся эмулировать присутствие одиночки и там. Чаще всего эта проблема проявляется при написании юнит-тестов.

**Пример кода:** [Python](Generating/Python/singleton.py), [JavaScript](Generating/JavaScript/singleton.js)

## **Структурные паттерны**

### Адаптер _(Adapter)_

**Адаптер** — это структурный паттерн, который позволяет подружить несовместимые объекты.

Адаптер выступает прослойкой между двумя объектами, превращая вызовы одного в вызовы понятные другому.

**Пример кода:** [Python](Structural/Python/adapter.py)

### Мост _(Bridge)_

**Мост** — это структурный паттерн, который разделяет бизнес-логику или большой класс на несколько отдельных иерархий, которые потом можно развивать отдельно друг от друга.

Одна из этих иерархий (абстракция) получит ссылку на объекты другой иерархии (реализация) и будет делегировать им основную работу. Благодаря тому, что все реализации будут следовать общему интерфейсу, их можно будет взаимозаменять внутри абстракции.

**Пример кода:** [Python](Structural/Python/bridge.py)

### Компоновщик _(Composite)_

**Компоновщик** — это структурный паттерн, который позволяет создавать дерево объектов и работать с ним так же, как и с единичным объектом.

Компоновщик давно стал синонимом всех задач, связанных с построением дерева объектов. Все операции компоновщика основаны на рекурсии и «суммировании» результатов на ветвях дерева.

**Пример кода:** [Python](Structural/Python/composite.py)

### Декоратор _(Decorator)_

**Декоратор** — это структурный паттерн, который позволяет добавлять объектам новые поведения на лету, помещая их в объекты-обёртки.

Декоратор позволяет оборачивать объекты бесчисленное количество раз благодаря тому, что и обёртки, и реальные оборачиваемые объекты имеют общий интерфейс.

**Пример кода:** [Python](Structural/Python/decorator.py)

## Фасад _(Facade)_

**Фасад** — это структурный паттерн, который предоставляет простой (но урезанный) интерфейс к сложной системе объектов, библиотеке или фреймворку.

Кроме того, что Фасад позволяет снизить общую сложность программы, он также помогает вынести код, зависимый от внешней системы в единственное место.

**Пример кода:** [Python](Structural/Python/facade.py)
