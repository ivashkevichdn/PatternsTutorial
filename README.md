# ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ

Паттерны (или шаблоны) проектирования описывают
типичные способы решения часто встречающихся
проблем при проектировании программ.

## **Классификация паттернов**

Паттерны отличаются по уровню сложности, детализации и охвата проектируемой системы. Проводя аналогию со строительством, вы можете повысить безопасность перекрёстка, поставив светофор, а можете заменить перекрёсток целой автомобильной развязкой с подземными переходами.

Самые низкоуровневые и простые паттерны — идиомы. Они не универсальны, поскольку применимы только в рамках одного языка программирования.

Самые универсальные — архитектурные паттерны, которые можно реализовать практически на любом языке. Они нужны для проектирования всей программы, а не отдельных её элементов.

Кроме того, паттерны отличаются и предназначением. В этой книге будут рассмотрены три основные группы паттернов:

- **Порождающие паттерны** беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.

- **Структурные паттерны** показывают различные способы построения связей между объектами.

- **Поведенческие паттерны** заботятся об эффективной коммуникации между объектами.

## **Порождающие паттерны**

### Абстрактная фабрика _(Abstract Factory)_

**Абстрактная фабрика** — это порождающий паттерн проектирования, который решает проблему создания целых семейств связанных продуктов, без указания конкретных классов продуктов.

Абстрактная фабрика задаёт интерфейс создания всех доступных типов продуктов, а каждая конкретная реализация фабрики порождает продукты одной из вариаций. Клиентский код вызывает методы фабрики для получения продуктов, вместо самостоятельного создания с помощью оператора new. При этом фабрика сама следит за тем, чтобы создать продукт нужной вариации.

**Пример кода:** [Python](Generating/Python/abstract_factory.py)

### Строитель _(Builder)_

**Строитель** — это порождающий паттерн проектирования, который позволяет создавать объекты пошагово.

В отличие от других порождающих паттернов, Строитель позволяет производить различные продукты, используя один и тот же процесс строительства.

**Пример кода:** [Python](Generating/Python/builder.py)

### Фабричный метод _(Factory Method)_

**Фабричный метод** — это порождающий паттерн проектирования, который решает проблему создания различных продуктов, без указания конкретных классов продуктов.

Фабричный метод задаёт метод, который следует использовать вместо вызова оператора new для создания объектов-продуктов. Подклассы могут переопределить этот метод, чтобы изменять тип создаваемых продуктов.

**Пример кода:** [Python](Generating/Python/factory_method.py)

### Прототип _(Prototype)_

**Прототип** — это порождающий паттерн, который позволяет копировать объекты любой сложности без привязки к их конкретным классам.

Все классы — Прототипы имеют общий интерфейс. Поэтому вы можете копировать объекты, не обращая внимания на их конкретные типы и всегда быть уверены, что получите точную копию. Клонирование совершается самим объектом-прототипам, что позволяет ему скопировать значения всех полей, даже приватных.

**Пример кода:** [Python](Generating/Python/prototype.py)

### Одиночка _(Singleton)_

**Одиночка** — это порождающий паттерн, который гарантирует существование только одного объекта определённого класса, а также позволяет достучаться до этого объекта из любого места программы.

Одиночка имеет такие же преимущества и недостатки, что и глобальные переменные. Его невероятно удобно использовать, но он нарушает модульность вашего кода.

Вы не сможете просто взять и использовать класс, зависящий от одиночки в другой программе. Для этого придётся эмулировать присутствие одиночки и там. Чаще всего эта проблема проявляется при написании юнит-тестов.

**Пример кода:** [Python](Generating/Python/singleton.py), [JavaScript](Generating/JavaScript/singleton.js)

## **Структурные паттерны**

### Адаптер _(Adapter)_

**Адаптер** — это структурный паттерн, который позволяет подружить несовместимые объекты.

Адаптер выступает прослойкой между двумя объектами, превращая вызовы одного в вызовы понятные другому.

**Пример кода:** [Python](Structural/Python/adapter.py)

### Мост _(Bridge)_

**Мост** — это структурный паттерн, который разделяет бизнес-логику или большой класс на несколько отдельных иерархий, которые потом можно развивать отдельно друг от друга.

Одна из этих иерархий (абстракция) получит ссылку на объекты другой иерархии (реализация) и будет делегировать им основную работу. Благодаря тому, что все реализации будут следовать общему интерфейсу, их можно будет взаимозаменять внутри абстракции.

**Пример кода:** [Python](Structural/Python/bridge.py)

### Компоновщик _(Composite)_

**Компоновщик** — это структурный паттерн, который позволяет создавать дерево объектов и работать с ним так же, как и с единичным объектом.

Компоновщик давно стал синонимом всех задач, связанных с построением дерева объектов. Все операции компоновщика основаны на рекурсии и «суммировании» результатов на ветвях дерева.

**Пример кода:** [Python](Structural/Python/composite.py)

### Декоратор _(Decorator)_

**Декоратор** — это структурный паттерн, который позволяет добавлять объектам новые поведения на лету, помещая их в объекты-обёртки.

Декоратор позволяет оборачивать объекты бесчисленное количество раз благодаря тому, что и обёртки, и реальные оборачиваемые объекты имеют общий интерфейс.

**Пример кода:** [Python](Structural/Python/decorator.py)

### Фасад _(Facade)_

**Фасад** — это структурный паттерн, который предоставляет простой (но урезанный) интерфейс к сложной системе объектов, библиотеке или фреймворку.

Кроме того, что Фасад позволяет снизить общую сложность программы, он также помогает вынести код, зависимый от внешней системы в единственное место.

**Пример кода:** [Python](Structural/Python/facade.py)

### Легковес _(Flyweight)_

**Легковес** — это структурный паттерн, который экономит память, благодаря разделению общего состояния, вынесенного в один объект, между множеством объектов.

Легковес позволяет экономить память, кешируя одинаковые данные, используемые в разных объектах.

**Пример кода:** [Python](Structural/Python/flyweight.py)

### Заместитель _(Proxy)_

**Заместитель** — это объект, который выступает прослойкой между клиентом и реальным сервисным объектом. Заместитель получает вызовы от клиента, выполняет свою функцию (контроль доступа, кеширование, изменение запроса и прочее), а затем передаёт вызов сервисному объекту.

Заместитель имеет тот же интерфейс, что и реальный объект, поэтому для клиента нет разницы — работать через заместителя или напрямую.

**Пример кода:** [Python](Structural/Python/proxy.py)

## **Поведенческие паттерны**

### Цепочка обязанностей _(Chain of Responsibility)_

**Цепочка обязанностей** — это поведенческий паттерн, позволяющий передавать запрос по цепочке потенциальных обработчиков, пока один из них не обработает запрос.

Избавляет от жёсткой привязки отправителя запроса к его получателю, позволяя выстраивать цепь из различных обработчиков динамически.

**Пример кода:** [Python](/Behavioral/Python/chain_of_responsibility.py)

### Итератор _(Iterator)_

**Итератор** — это поведенческий паттерн, позволяющий последовательно обходить сложную коллекцию, без раскрытия деталей её реализации.

Благодаря Итератору, клиент может обходить разные коллекции одним и тем же способом, используя единый интерфейс итераторов.

**Пример кода:** [Python](/Behavioral/Python/chain_of_responsibility.py)

### Снимок _(Memento)_

**Снимок** — это поведенческий паттерн, позволяющий делать снимки внутреннего состояния объектов, а затем восстанавливать их.

При этом Снимок не раскрывает подробностей реализации объектов, и клиент не имеет доступа к защищённой информации объекта.

**Пример кода:** [Python](/Behavioral/Python/memento.py)

### Шаблонный метод _(Template Method)_

**Шаблонный метод** — это поведенческий паттерн, задающий скелет алгоритма в суперклассе и заставляющий подклассы реализовать конкретные шаги этого алгоритма.

**Пример кода:** [Python](/Behavioral/Python/template_method.py)

### Команда _(Command)_

**Команда** — это поведенческий паттерн, позволяющий заворачивать запросы или простые операции в отдельные объекты.

Это позволяет откладывать выполнение команд, выстраивать их в очереди, а также хранить историю и делать отмену.

**Пример кода:** [Python](/Behavioral/Python/command.py)

### Посредник _(Mediator)_

**Посредник** — это поведенческий паттерн, который упрощает коммуникацию между компонентами системы.

Посредник убирает прямые связи между отдельными компонентами, заставляя их общаться друг с другом через себя.

**Пример кода:** [Python](/Behavioral/Python/mediator.py)

### Наблюдатель _(Observer)_

**Наблюдатель** — это поведенческий паттерн, который позволяет объектам оповещать другие объекты об изменениях своего состояния.

При этом наблюдатели могут свободно подписываться и отписываться от этих оповещений.

**Пример кода:** [Python](/Behavioral/Python/observer.py), [JavaScript](/Behavioral/JavaScript/observer.js)

### Стратегия _(Strategy)_

**Стратегия** — это поведенческий паттерн, выносит набор алгоритмов в собственные классы и делает их взаимозаменимыми.

Другие объекты содержат ссылку на объект-стратегию и делегируют ей работу. Программа может подменить этот объект другим, если требуется иной способ решения задачи.

**Пример кода:** [Python](/Behavioral/Python/strategy.py)

### Посетитель _(Visitor)_

**Посетитель** — это поведенческий паттерн, который позволяет добавить новую операцию для целой иерархии классов, не изменяя код этих классов.

**Пример кода:** [Python](/Behavioral/Python/visitor.py)
